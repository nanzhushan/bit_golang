#### channel
	go的通道就相当于一个kafka(第三方中间件)一样,kafka 可以多线程生产消息 也可以多线程消费消息
	channel 可以理解为linux的管道
	channel作用: 1 通讯 2 阻塞

#### select 语句
Go 的select语句是一种仅能用于channl发送和接收消息的专用语句，此语句运行期间是阻塞的；当select中没有case语句的时候，会阻塞当前的groutine

#### go的全局变量/函数和局部变量/函数
大写字母开头是全局的，小写字母开头是局部的(局部的包可见)	

#### Goroutine 状态
Go调度器是Go运行时的一部分,Go运行时被编译到了你的程序里。这就表示Go调度器是运行在用户态的.一个Goroutine(协程)有3种状态如下:

* 阻塞态：这表示Goroutine被暂停了,要等待一些事情发生了才能继续.有可能是因为要等待系统调用或者互斥调用（atomic和mutex操作).这些情况导致性能不佳的根因。

* 就绪态：这代表Goroutine想要一个M来执行分配给它的指令.如果你有很多Goroutine都需要M,那么Goroutine就需要等较长的时间.并且每个Goroutine被分配的执行时间也就更短了,这种情况也会导致性能下降。

* 运行态：这表示Goroutine被交给了一个M(系统线程)执行，正在执行它的指令.这是每个人都希望的
```
package main
import (
	"fmt"
	"runtime"
)
func main()  {
	fmt.Println(runtime.NumCPU())
}
```

#### 调度器
* 在多核情况下:
	加了go关键字就是一个go协程(goruntine),和主协程有公平的调度权利
* 单核情况下:
	单核是伪并发,一个cpu核只能调度一个,单核处理器任意时刻只准许一个线程在跑


##### 并发和并行(并发不等于并行)
* 并发： 意味着不按顺序执行.给定一组指令,可以按顺序执行,也可以找一种方式不按顺序执行,但仍能得到同样的结果
* 并行: 意味着 2个或者2个以上的指令可以在同一时间一起执行。这和并发的概念不同。只有你的机器有至少2个hardware threads 才能使你的程序达到并行效果.

负荷类型:
* CPU 密集型的工作,你需要通过并行来达到并发
	因为同一个时刻可以处理多个Goroutine(协程)，就像py有全局锁,一个时刻只准许一个线程在跑.所以这种负荷类型下
	py的多线程并没有提高效率
* IO 密集型的工作,你不需要并行来保证并发

#### 调度器的起源
* 第一时代: 远古时代
* 第二时代: 进程时代,有了操作系统 可以实现多进程并发
* 第三时代: 线程时代
```
一个进程可以有多个线程，CPU在执行调度的时候切换的是线程，如果下一个线程也是当前进程的，就只有线程切换，“很快”就能完成，如果下一个线程不是当前的进程，就需要切换进程，这就得费点时间了。

这个时代，CPU的调度切换的是进程和线程。多线程看起来很美好,但实际多线程编程并不理想,一是由于线程的设计本身有点复杂，而是由于需要考虑很多底层细节，比如锁和冲突检测。
```

* 第四时代: 协程时代

多进程、多线程已经提高了系统的并发能力,但是在当今互联网高并发场景下,为每个任务都创建一个线程是不现实的,因为会消耗大量的内存,线程多了之后调度也会消耗大量的CPU

	线程分为内核态线程和用户态线程，用户态线程需要绑定内核态线程，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程

	协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程

	协程是个好东西，不少语言支持了协程，比如：Lua、Erlang、Java（C++即将支持），就算语言不支持，也有库支持协程，比如C语言的coroutine（风云大牛作品）、Kotlin的kotlinx.coroutines、Python的gevent。

	在Go中，线程是运行goroutine(协程)的实体，调度器的功能是把可运行的goroutine分配到工作线程上，进程又包含线程

